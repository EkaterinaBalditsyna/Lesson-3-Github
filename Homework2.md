## Инструкция по работе с Git и удаленными репозиториями

## Что такое Git?
Git — это система контроля версий (VCS), которая позволяет отслеживать и фиксировать изменения в коде: вы можете восстановить код в случае сбоя или откатить до более ранних версий. А ещё это must-have инструмент для взаимодействия нескольких разработчиков на одном проекте. 
## Подготовка репозитория
Для создания репозитория необходимо выполнить команду *__git init__* в папке с репозиторием и у вас создастся репозиторий (появится скрытая папка .git).

## Создание коммитов

Команда _git commit_ откроет текстовый редактор для ввода сообщения коммита. Также эта команда принимает несколько аргументов:

* -m позволяет написать сообщение вместе с командой, не открывая редактор. Например git commit -m "Пофиксил баг";
* -a переносит все отслеживаемые файлы в область подготовленных файлов и включает их в коммит (позволяет пропустить git add перед коммитом);
* --amend заменяет последний коммит новым изменённым коммитом, что бывает полезно, если вы неправильно набрали сообщение последнего коммита или забыли включить в него какие-то файлы.

### Основные команды

* git status – получить информацию от git о его текущем состоянии
* git add – добавить файл или файлы к следующему коммиту
* git commit -m “message” – создание коммита.
* git log – вывод на экран истории всех коммитов с их хеш-кодами
* git branch – посмотреть список веток в репозитории
*  git branch <название ветки> – создать новую ветку
* git checkout <название ветки> – переход к другой ветке
* git branch -d <название ветки> – удалить ветку.

## Просмотр изменений

Команда *git status* отображает все файлы, которые различаются между тремя разделами. У файлов есть 4 состояния:

1. Неотслеживаемый (untracked) — находится в рабочей директории, но нет ни одной версии в HEAD или в области подготовленных файлов (Git не знает о файле).
2. Изменён (modified) — в рабочей директории есть более новая версия по сравнению с хранящейся в HEAD или в области подготовленных файлов (изменения не находятся в следующем коммите).
3. Подготовлен (staged) — в рабочей директории и области подготовленных файлов есть более новая версия по сравнению с хранящейся в HEAD (готов к коммиту).
4. Без изменений — одна версия файла во всех разделах, т. е. в последнем коммите содержится актуальная версия.

Чтобы посмотреть **сами изменения**, а не изменённые файлы, можно использовать следующие команды:

*_git diff_ — сравнение рабочей директории с областью подготовленных файлов;
*_git diff --staged_ — сравнение области подготовленных файлов с HEAD.
Если использовать аргумент <файл/папка>, то diff покажет изменения только для указанных файлов/папок, например git diff src/.

## Удаленные репозитории 
Можно хранить историю коммитов удалённых репозиториев, которую можно отслеживать и обновлять. *git remote -v* выводит список удалённых репозиториев, которые мы отслеживаем, и имена, которые мы им присвоили.

При использовании команды *git clone <url репозитория>* мы не только загружаем себе копию репозитория, но и неявно отслеживаем удалённый сервер, который находится по указанному адресу и которому присваивается имя origin.

Наиболее употребляемые команды:

*_git remote add <имя> <url>_ — добавляет удалённый репозиторий с заданным именем;
*_git remote remove <имя>_ — удаляет удалённый репозиторий с заданным именем;
git remote rename <старое имя> <новое имя> — переименовывает удалённый репозиторий;
*_git remote set-url <имя> <url>_ — присваивает репозиторию с именем новый адрес;
*_git remote show <имя>_ — показывает информацию о репозитории.

Следующие команды работают с **удалёнными ветками**:
*_git fetch <имя> <ветка>_ — получает данные из ветки заданного репозитория, но не сливает изменения;
*_git pull <имя> <ветка>_ — сливает данные из ветки заданного репозитория;
*_git push <имя> <ветка>_ — отправляет изменения в ветку заданного репозитория. Если локальная ветка уже отслеживает удалённую, то можно использовать просто *git push* или *git pull*.

## Работа с ветками

Ветвление — это возможность работать над разными версиями проекта: вместо одного списка с упорядоченными коммитами история будет расходиться в определённых точках. Каждая ветвь содержит легковесный указатель HEAD на последний коммит, что позволяет без лишних затрат создать много веток. Ветка по умолчанию называется master, но лучше назвать её в соответствии с разрабатываемой в ней функциональностью.

Итак, есть общий указатель HEAD и HEAD для каждой ветки. Переключение между ветками предполагает только перемещение HEAD в HEAD соответствующей ветки.

Команды:

* _git branch <имя ветки>_ — создаёт новую ветку с HEAD, указывающим на HEAD. Если не передать аргумент <имя ветки>, то команда выведет список всех локальных веток;
* git checkout <имя ветки>_ — переключается на эту ветку. Можно передать опцию -b, чтобы создать новую ветку перед переключением;
* _git branch -d <имя ветки>_ — удаляет ветку.
Локальный и удалённый репозитории могут иметь немало ветвей, поэтому когда вы отслеживаете удалённый репозиторий — отслеживается удалённая ветка (git clone привязывает вашу ветку master к ветке origin/master удалённого репозитория).

Привязка к удалённой ветке:

* _git branch -u_ <имя удалённого репозитория>/<удалённая ветка> — привязывает текущую ветку к указанной удалённой ветке;
* _git checkout --track_ <имя удалённого репозитория>/<удалённая ветка> — аналог предыдущей команды;
* _git checkout -b <ветка>_ <имя удалённого репозитория>/<удалённая ветка> — создаёт новую локальную ветку и начинает отслеживать удалённую;
* _git branch --vv_ — показывает локальные и отслеживаемые удалённые ветки;
* _git checkout <удалённая ветка>_ — создаёт локальную ветку с таким же именем, как у удалённой, и начинает её отслеживать.
В общем, *git checkout* связан с изменением места, на которое указывает HEAD ветки, что похоже на то, как git reset перемещает общий HEAD.
## Продвинутое использование

[Ссылка!](https://learngitbranching.js.org/?locale=ru_RU)
